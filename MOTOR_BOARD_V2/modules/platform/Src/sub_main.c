/*
 * file        : sub_main.c
 * description : <insert here>
 * copyright   : (c) 2019 Kickmaker
 * author      : Luis CRUZ
 */

/**
 * @addtogroup highlevel High level
 * @{
 */
/**
 * @addtogroup highlevel_submain Sub main
 * @{
 */
/**
 * @file
 *
 * @brief Sub main of the system
 *
 * @details Hardware peripherals and configuration can be handled using the STM32CubeMX software.
 * When generating code, this software create a predefined source code structure with hard coded sections.
 * This sub_main.c file is used from within the main.c file generated by the tool and allow
 * for more flexibility than the main.c file.
 */
/** @} */
/** @} */



// ==================================================
//     INCLUDE
// ==================================================

#include "sub_main.h"


// ==================================================
//     DEFINE
// ==================================================

// ==================================================
//     LOCAL PROTOTYPES
// ==================================================

/**
 * Global error handler
 */
void
sub_main_ErrorHandler ( void );

/**
 * Initialize software services
 *
 * @return HAL_OK if all services have been initialized successfully, HAL_ERROR otherwise
 */
HAL_StatusTypeDef
sub_main_InitServices ( void );

/**
 * Initialize scheduler tasks
 *
 * @return HAL_OK if all tasks have been initialized successfully, HAL_ERROR otherwise
 */
HAL_StatusTypeDef
sub_main_InitTasks ( void );


/**
 * GPIO interrupt callback for hall sensors
 *
 * @param GPIO_Pin Specifies the port pin connected to corresponding EXTI line
 */
void
HAL_GPIO_EXTI_Callback ( uint16_t GPIO_Pin );

/**
 * Hardware timer interrupt callback
 *
 * @param htim Hardware timer handle
 */
void
HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim );

/**
 * UART TX interrupt callback
 *
 * @param huart Uart peripheral handle
 */
void
HAL_UART_TxCpltCallback ( UART_HandleTypeDef * huart );

/**
 * UART RX interrupt callback
 *
 * @param huart Uart peripheral handle
 */
void
HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart );

/**
 * ADC interrupt callback
 *
 * @param _hadc ADC peripheral handle
 */
void
HAL_ADC_ConvCpltCallback ( ADC_HandleTypeDef * _hadc );


// ==================================================
//     GLOBAL VARIABLES
// ==================================================

///// Peripherals

///// Devs
DEVS_t devs;
extern bool start_auto_calib;
extern SCHEDULER_TASK_t task_MotorCtrl;
extern SCHEDULER_TASK_t task_AutoCalibration;
extern SCHEDULER_TASK_t task_Com_mgt;
extern SCHEDULER_TASK_t task_CurrentCalculation;
extern SCHEDULER_TASK_t task_ADC;
// ==================================================
//     PUBLIC FUNCTIONS
// ==================================================

void
SUB_MAIN ( void )
{
    HAL_StatusTypeDef status = HAL_OK;

    ///// Services initialization
    status |= sub_main_InitServices();

    if ( status != HAL_OK )
    {
        sub_main_ErrorHandler();
//        error = Init_error;
        return;
    }

	switch (board.number)
	{
	case TYPE_STANDER_RIGHT :
		CONSOLE("Right stander board "EOL );
		break;

	case TYPE_WHEEL_RIGHT :
		CONSOLE("Right wheel board "EOL );
		break;

	case TYPE_STANDER_LEFT :
		CONSOLE("Left stander board "EOL );
		break;

	case TYPE_WHEEL_LEFT :
		CONSOLE("Left wheel board"EOL );
		break;
	}

    ///// Tasks initialization
    status |= sub_main_InitTasks();

    if ( status != HAL_OK )
    {
        sub_main_ErrorHandler();
//        error = Init_error;
        return;
    }

    for(;;)
    {
    	if(board.flags.status_flag.single.auto_calib_status == In_progress )
    	{
    		if(!start_auto_calib)
    		{
    			start_auto_calib = true;
    			SCHEDULER_Task_Register( &task_AutoCalibration );
    			SCHEDULER_Task_Start   ( &task_AutoCalibration );
    		}
    	}
    	else if( board.flags.status_flag.single.auto_calib_status ==  Done)
    	{
    		if(start_auto_calib)
    		{
    			//Reset pour relancer une prochaine auto-calibration si besoin
				start_auto_calib = false;
				//On arrete la tache d'auto-calibration
				SCHEDULER_Task_Stop   ( &task_AutoCalibration );
				SCHEDULER_Task_Unregister( &task_AutoCalibration );
    		}
    	}
    }
}



// ==================================================
//     LOCAL FUNCTIONS
// ==================================================

void
sub_main_ErrorHandler ( void )
{
    CONSOLE( EOL );
    CONSOLE( "ERROR in initialisation" );
}

HAL_StatusTypeDef
sub_main_InitServices ( void )
{
    HAL_StatusTypeDef status = HAL_OK , dev_status;

    memset( ( void * )&devs , 0x00 , sizeof( DEVS_t ) );

   ///// Initialize the console
   dev_status    = CONSOLE_Init( &huart1 );
   devs.console  = ( dev_status == HAL_OK ) ? DEV_STATUS_ENABLED : DEV_STATUS_DISABLED;
   status       |= dev_status;

   // TODO: Initialize any other peripheral
   if ( devs.console == DEV_STATUS_ENABLED )
   {
	   CONSOLE(
		   "GEMA (c) Motor Board \r V. %d.%d.%d " EOL ,
		   MAJOR , MINOR , REVISION
	   );
   }

    ///// Scheduler
    SCHEDULER_RESULT_t scheduler_result;

    scheduler_result  = SCHEDULER_Init( 100 );
    dev_status        = ( scheduler_result == SCHEDULER_RESULT_SUCCESS ) ? HAL_OK : HAL_ERROR;
    devs.scheduler    = ( dev_status == HAL_OK ) ? DEV_STATUS_ENABLED : DEV_STATUS_DISABLED;
    status           |= dev_status;
    if ( devs.console == DEV_STATUS_ENABLED )
    {
    	status == HAL_OK ?
    	    CONSOLE( "Scheduler               : OK" EOL ) :
		    CONSOLE( "Scheduler               : KO" EOL );
    }

    return status;
}

HAL_StatusTypeDef
sub_main_InitTasks ( void )
{
    HAL_StatusTypeDef status = HAL_OK ;

    ///// Task: Motor control
	status     |= SCHEDULER_Task_Register( &task_MotorCtrl );
	status     |= SCHEDULER_Task_Start   ( &task_MotorCtrl );

	///// Task: Calcul courant
	status     |= SCHEDULER_Task_Register( &task_CurrentCalculation );
	status     |= SCHEDULER_Task_Start   ( &task_CurrentCalculation );

    ///// Task: Communication management
	status     |= SCHEDULER_Task_Register( &task_Com_mgt );
	status     |= SCHEDULER_Task_Start   ( &task_Com_mgt );

	if( board.select.type_IsStander )
	{
		///// Task: ADC Fx
		status     |= SCHEDULER_Task_Register( &task_ADC );
		status     |= SCHEDULER_Task_Start   ( &task_ADC );

	}

	//on ne demarre le timer qu'apres avoir préparé les taches afin d'etre sur qu'elle sont toutes prete dès la premiere interruption
    if ( HAL_TIM_Base_Start_IT(&htim7) != HAL_OK)
	{
    	status = HAL_ERROR;
	}

    return status;
}


void
HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim )
{

    if ( htim->Instance == htim7.Instance )
    {
        SCHEDULER_MonitoringLoop();
    }
}


void
HAL_UART_TxCpltCallback ( UART_HandleTypeDef * huart )
{
    if ( huart->Instance == huart1.Instance )
    {
        CONSOLE_UART_TxCpltCallback();
    }
}


void
HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart )
{

    if ( huart->Instance == huart1.Instance )
    {
        CONSOLE_UART_RxCpltCallback();
    }
}


void
HAL_ADC_ConvCpltCallback ( ADC_HandleTypeDef * _hadc )
{

}


// End of file
